# 세마포어, 뮤텍스, 모니터의 차이 그리고 교착상태(deadlock)

## 뮤텍스(Mutex)

![Untitled](https://user-images.githubusercontent.com/47595515/212967244-b55a7fe6-35c5-4cdf-86dd-1a5bca5f74d4.png)

- 세마포어의 단순한 버전
- 공유자원이나 코드의 일부분에 대해 상호배제를 해야하는 경우 사용하면 좋다
- 공유자원을 사용하기 전에 설정하고 사용한 후에 해제하는 잠금
- 잠금이 설정되면 다른 스레드는 잠긴 코드 영역에 접근할 수 없다
- 뮤텍스는 하나의 상태(잠금 또는 잠금해제)만 가진다

## 세마포어

![Untitled 1](https://user-images.githubusercontent.com/47595515/212967230-c3c0f143-eebf-4c9b-ad5a-67b0038868d9.png)

- Dijkstra가 제안
- 간단한 정수 값과 두가지 함수로 공유 자원에 대한 접근을 처리
    - wait() = down() = P()
        - 세마포어 값이 0일 경우 대기
        - 세마포어 값이 0보다 클 경우 1을 감소시키고 계속 수행
    - signal() = up() = V()
        - 세마포어 값을 1 증가 시킨다
        - 세마포어 값이 0이고 대기중인 프로세스가 있을 경우 해당 프로세스를 깨우고 세마포어 값은 그대로 0
    - 이 모든 과정은 원자적(atomic)으로 이루어진다

### 바이너리 세마포어

- 0과 1의 두 가지 값만 가질 수 있는 세마포어
- 구현의 유사성으로 인해 뮤텍스와 비슷
- 뮤텍스와의 차이

    | **바이너리 세마포어**                                  | **뮤텍스**                                |
    |------------------------------------------------|----------------------------------------|
    | 신호 전달 메커니즘 기반으로 동작                             | 잠금 메커니즘 기반으로 동작                        |
    | 현재 스레드보다 우선순위가 높은 스레드가 바이너리 세마포어를 해제하고 잠글 수 있음 | 뮤텍스를 획득한 스레드는 임계영역에서 나갈 때만 뮤텍스 해제 가능   |
    | 값은 `wait()`, `signal()`에 따라 변경                 | 값이 locked, unlocked 으로 수정              |
    | 여러 개의 스레드가 동시에 이진 세마포어를 획득 가능                  | 한 번에 하나의 스레드만 뮤텍스를 획득 가능               |
    | 소유권이 없다                                        | 뮤텍스를 소유한 스레드만 잠금을 해제 가능하므로 소유권이 있음     |
    | 다른 스레드/프로세스가 잠금 해제가 가능하기 때문에 뮤텍스보다 빠르다.        | 획득한 스레드만 잠금 해제가 가능하므로 바이너리 세마포어보다 느리다. |

### 카운팅 세마포어

- 여러 개의 값을 가질 수 있는 세마포어
- 여러 자원에 대한 접근을 제어하는 데에 사용

## 모니터

![Untitled 2](https://user-images.githubusercontent.com/47595515/212967237-4fa0f6f2-64ae-4a00-8dd6-33a1b9267d18.png)

- 둘 이상의 스레드나 프로세스가 공유자원에 안전하게 접근할 수 있도록 공유자원을 숨기고 해당 접근에 대해 인터페이스만 제공
- 모니터 큐를 통해 공유자원에 대한 작업들을 순차적으로 처리
- 세마포어보다 구현하기 쉬우며 모니터에서 상호배제는 자동인 반면 세마포어에서는 명시적으로 구현해야 한다

## 교착상태(Deadlock)

![Untitled 3](https://user-images.githubusercontent.com/47595515/212967241-b8d0e9cd-3db9-44b0-90ec-b7bb3526b5f4.png)

- 두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태

### 교착상태 원인

- 상호배제(Mutual Exclusion) : 한 프로세스가 자원을 독점하고 있으며 다른 프로세스들은 접근이 불가능
- 점유대기(Hold and Wait) : 특정 프로세스가 점유한 자원을 다른 프로세스가 사용하기 위해 대기
- 비선점(No Preemption) : 다른 프로세스의 자원을 사용이 끝날 때까지 강제적으로 뺏을 수 없다
- 환형대기(Circular Wait) : 프로세스 A가 프로세스 B의 자원을 요구하고 B는 A의 자원을 요구하는 서로가 서로의 자원을 요구하는 상태

### 교착상태 해결방법

- 교착상태 예방
    - 교착상태가 애초에 발생하지 않도록 하는 방법
    - 발생원인 4가지 중 하나를 부정함으로써 가능한 기법
    - 실제로 구현이 난해하고 불가능한 방법들이 많고 가능하더라도 자원의 낭비가 심할 수 밖에 없는 방법들이 대부분
- 교착상태 회피
    - 교착상태의 가능성이 없을 때만 자원 할당
    - 대표적인 방법으로 “은행원 알고리즘”이 있다
    - 은행원 알고리즘
        - 총 자원의 양과 현재 할당한 자원의 양을 기준으로 안정 또는 불안정 상태로 나누고 안정 상태로 가도록 자원을 할당하는 알고리즘
        - 단점
            1. 할당할 수 있는 자원의 수가 일정해야 한다.
            2. 프로세스의 수가 일정해야 한다.
            3. 항상 안전상태를 유지해야 하므로, 자원에 대한 이용률이 굉장히 낮다.
            4. 프로세스가 요구하는 최대 자원 요구량을 미리 알아야 한다.
            5. 프로세스들은 반드시 유한 시간 내에 사용한 자원을 반납해야 한다.
        - 이러한 가정들이 모두 이루어졌을 떄 사용이 가능하기 때문에 사용률은 굉장히 낮다
- 교착상태 탐지
    - 탐지알고리즘을 통해 교착상태인지 판별
    - 탐지알고리즘은 오버헤드가 있기 때문에 얼마나 자주 교착상태가 발생하고, 얼마나 많은 프로세스가 교착상태에 연루되어 있는지에 따라 호출 빈도를 조절해야 한다
- 교착상태 회복
    - 교착상태가 탐지되었을 경우 회복
    - 회복기법
        - 사용자가 직접 처리
            - 교착상태에 걸려있는 프로세스 중, 어느 하나의 프로세스를 사용자가 강제로 종료해서 교착상태 회복
        - 시스템에 의해 처리
            - 프로세스 중지
                - 한 개 이상의 프로세스를 중지시킴으로써 교착상태를 회복
                - 교착상태에 속해 있는 모든 프로세스를 중지 시키는 방법
                    - 확실하게 교착상태 회복이 가능하지만 결과들을 폐기하고 처음부터 다시 진행해야되기 때문에 비용이 크다
                - 교착상태가 해결 될 때까지 한 프로세스씩 중지 시키는 방법
                    - 탐지 알고리즘을 호출하여 교착상태 여부를 판별해야 하기 때문에 오버헤드가 크다
            - 자원 선점
                - 프로세스들로부터 자원을 빼앗아서 교착상태가 해결 될 때까지 다른 프로세스들에게 할당해 주는 방식
                - 고려해야할 조건
                    1. 희생자 선택(selection of victim)
                        - 최소의 피해를 줄 수 있는 프로세스를 선택
                    2. 복귀(rollback)
                        - 선점된 프로세스를 문제 없던 이전 상태로 롤백
                        - 보통 가장 안전한 방법은 프로세스를 중지하고 재시작
                    3. 기아(starvation)
                        - 한 프로세스가 계속 선점되어 기아상태가 되는 것을 방지
                        - 한 가지 방법은 우선 순위를 사용하여 선점 될때마다 우선순위를 높이는 것